package handler

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/gusantoniassi/navegante/gateway/containergateway.Container -o ./api/handler/container_mock_test.go

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/gusantoniassi/navegante/core/entity"
)

// ContainerMock implements containergateway.Container
type ContainerMock struct {
	t minimock.Tester

	funcContainerGet          func(cid entity.ContainerID) (cp1 *entity.Container, err error)
	inspectFuncContainerGet   func(cid entity.ContainerID)
	afterContainerGetCounter  uint64
	beforeContainerGetCounter uint64
	ContainerGetMock          mContainerMockContainerGet

	funcContainerGetAll          func() (cpa1 []*entity.Container, err error)
	inspectFuncContainerGetAll   func()
	afterContainerGetAllCounter  uint64
	beforeContainerGetAllCounter uint64
	ContainerGetAllMock          mContainerMockContainerGetAll

	funcContainerKill          func(c *entity.Container) (err error)
	inspectFuncContainerKill   func(c *entity.Container)
	afterContainerKillCounter  uint64
	beforeContainerKillCounter uint64
	ContainerKillMock          mContainerMockContainerKill

	funcContainerRefresh          func(c *entity.Container) (err error)
	inspectFuncContainerRefresh   func(c *entity.Container)
	afterContainerRefreshCounter  uint64
	beforeContainerRefreshCounter uint64
	ContainerRefreshMock          mContainerMockContainerRefresh

	funcContainerRemove          func(c *entity.Container) (err error)
	inspectFuncContainerRemove   func(c *entity.Container)
	afterContainerRemoveCounter  uint64
	beforeContainerRemoveCounter uint64
	ContainerRemoveMock          mContainerMockContainerRemove

	funcContainerRestart          func(c *entity.Container) (err error)
	inspectFuncContainerRestart   func(c *entity.Container)
	afterContainerRestartCounter  uint64
	beforeContainerRestartCounter uint64
	ContainerRestartMock          mContainerMockContainerRestart

	funcContainerRun          func(c *entity.Container) (err error)
	inspectFuncContainerRun   func(c *entity.Container)
	afterContainerRunCounter  uint64
	beforeContainerRunCounter uint64
	ContainerRunMock          mContainerMockContainerRun

	funcContainerStats          func(cid string) (sp1 *entity.Stat, err error)
	inspectFuncContainerStats   func(cid string)
	afterContainerStatsCounter  uint64
	beforeContainerStatsCounter uint64
	ContainerStatsMock          mContainerMockContainerStats

	funcContainerStatsAll          func() (spa1 []*entity.Stat, err error)
	inspectFuncContainerStatsAll   func()
	afterContainerStatsAllCounter  uint64
	beforeContainerStatsAllCounter uint64
	ContainerStatsAllMock          mContainerMockContainerStatsAll

	funcContainerStop          func(c *entity.Container) (err error)
	inspectFuncContainerStop   func(c *entity.Container)
	afterContainerStopCounter  uint64
	beforeContainerStopCounter uint64
	ContainerStopMock          mContainerMockContainerStop
}

// NewContainerMock returns a mock for containergateway.Container
func NewContainerMock(t minimock.Tester) *ContainerMock {
	m := &ContainerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ContainerGetMock = mContainerMockContainerGet{mock: m}
	m.ContainerGetMock.callArgs = []*ContainerMockContainerGetParams{}

	m.ContainerGetAllMock = mContainerMockContainerGetAll{mock: m}

	m.ContainerKillMock = mContainerMockContainerKill{mock: m}
	m.ContainerKillMock.callArgs = []*ContainerMockContainerKillParams{}

	m.ContainerRefreshMock = mContainerMockContainerRefresh{mock: m}
	m.ContainerRefreshMock.callArgs = []*ContainerMockContainerRefreshParams{}

	m.ContainerRemoveMock = mContainerMockContainerRemove{mock: m}
	m.ContainerRemoveMock.callArgs = []*ContainerMockContainerRemoveParams{}

	m.ContainerRestartMock = mContainerMockContainerRestart{mock: m}
	m.ContainerRestartMock.callArgs = []*ContainerMockContainerRestartParams{}

	m.ContainerRunMock = mContainerMockContainerRun{mock: m}
	m.ContainerRunMock.callArgs = []*ContainerMockContainerRunParams{}

	m.ContainerStatsMock = mContainerMockContainerStats{mock: m}
	m.ContainerStatsMock.callArgs = []*ContainerMockContainerStatsParams{}

	m.ContainerStatsAllMock = mContainerMockContainerStatsAll{mock: m}

	m.ContainerStopMock = mContainerMockContainerStop{mock: m}
	m.ContainerStopMock.callArgs = []*ContainerMockContainerStopParams{}

	return m
}

type mContainerMockContainerGet struct {
	mock               *ContainerMock
	defaultExpectation *ContainerMockContainerGetExpectation
	expectations       []*ContainerMockContainerGetExpectation

	callArgs []*ContainerMockContainerGetParams
	mutex    sync.RWMutex
}

// ContainerMockContainerGetExpectation specifies expectation struct of the Container.ContainerGet
type ContainerMockContainerGetExpectation struct {
	mock    *ContainerMock
	params  *ContainerMockContainerGetParams
	results *ContainerMockContainerGetResults
	Counter uint64
}

// ContainerMockContainerGetParams contains parameters of the Container.ContainerGet
type ContainerMockContainerGetParams struct {
	cid entity.ContainerID
}

// ContainerMockContainerGetResults contains results of the Container.ContainerGet
type ContainerMockContainerGetResults struct {
	cp1 *entity.Container
	err error
}

// Expect sets up expected params for Container.ContainerGet
func (mmContainerGet *mContainerMockContainerGet) Expect(cid entity.ContainerID) *mContainerMockContainerGet {
	if mmContainerGet.mock.funcContainerGet != nil {
		mmContainerGet.mock.t.Fatalf("ContainerMock.ContainerGet mock is already set by Set")
	}

	if mmContainerGet.defaultExpectation == nil {
		mmContainerGet.defaultExpectation = &ContainerMockContainerGetExpectation{}
	}

	mmContainerGet.defaultExpectation.params = &ContainerMockContainerGetParams{cid}
	for _, e := range mmContainerGet.expectations {
		if minimock.Equal(e.params, mmContainerGet.defaultExpectation.params) {
			mmContainerGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmContainerGet.defaultExpectation.params)
		}
	}

	return mmContainerGet
}

// Inspect accepts an inspector function that has same arguments as the Container.ContainerGet
func (mmContainerGet *mContainerMockContainerGet) Inspect(f func(cid entity.ContainerID)) *mContainerMockContainerGet {
	if mmContainerGet.mock.inspectFuncContainerGet != nil {
		mmContainerGet.mock.t.Fatalf("Inspect function is already set for ContainerMock.ContainerGet")
	}

	mmContainerGet.mock.inspectFuncContainerGet = f

	return mmContainerGet
}

// Return sets up results that will be returned by Container.ContainerGet
func (mmContainerGet *mContainerMockContainerGet) Return(cp1 *entity.Container, err error) *ContainerMock {
	if mmContainerGet.mock.funcContainerGet != nil {
		mmContainerGet.mock.t.Fatalf("ContainerMock.ContainerGet mock is already set by Set")
	}

	if mmContainerGet.defaultExpectation == nil {
		mmContainerGet.defaultExpectation = &ContainerMockContainerGetExpectation{mock: mmContainerGet.mock}
	}
	mmContainerGet.defaultExpectation.results = &ContainerMockContainerGetResults{cp1, err}
	return mmContainerGet.mock
}

//Set uses given function f to mock the Container.ContainerGet method
func (mmContainerGet *mContainerMockContainerGet) Set(f func(cid entity.ContainerID) (cp1 *entity.Container, err error)) *ContainerMock {
	if mmContainerGet.defaultExpectation != nil {
		mmContainerGet.mock.t.Fatalf("Default expectation is already set for the Container.ContainerGet method")
	}

	if len(mmContainerGet.expectations) > 0 {
		mmContainerGet.mock.t.Fatalf("Some expectations are already set for the Container.ContainerGet method")
	}

	mmContainerGet.mock.funcContainerGet = f
	return mmContainerGet.mock
}

// When sets expectation for the Container.ContainerGet which will trigger the result defined by the following
// Then helper
func (mmContainerGet *mContainerMockContainerGet) When(cid entity.ContainerID) *ContainerMockContainerGetExpectation {
	if mmContainerGet.mock.funcContainerGet != nil {
		mmContainerGet.mock.t.Fatalf("ContainerMock.ContainerGet mock is already set by Set")
	}

	expectation := &ContainerMockContainerGetExpectation{
		mock:   mmContainerGet.mock,
		params: &ContainerMockContainerGetParams{cid},
	}
	mmContainerGet.expectations = append(mmContainerGet.expectations, expectation)
	return expectation
}

// Then sets up Container.ContainerGet return parameters for the expectation previously defined by the When method
func (e *ContainerMockContainerGetExpectation) Then(cp1 *entity.Container, err error) *ContainerMock {
	e.results = &ContainerMockContainerGetResults{cp1, err}
	return e.mock
}

// ContainerGet implements containergateway.Container
func (mmContainerGet *ContainerMock) ContainerGet(cid entity.ContainerID) (cp1 *entity.Container, err error) {
	mm_atomic.AddUint64(&mmContainerGet.beforeContainerGetCounter, 1)
	defer mm_atomic.AddUint64(&mmContainerGet.afterContainerGetCounter, 1)

	if mmContainerGet.inspectFuncContainerGet != nil {
		mmContainerGet.inspectFuncContainerGet(cid)
	}

	mm_params := &ContainerMockContainerGetParams{cid}

	// Record call args
	mmContainerGet.ContainerGetMock.mutex.Lock()
	mmContainerGet.ContainerGetMock.callArgs = append(mmContainerGet.ContainerGetMock.callArgs, mm_params)
	mmContainerGet.ContainerGetMock.mutex.Unlock()

	for _, e := range mmContainerGet.ContainerGetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmContainerGet.ContainerGetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmContainerGet.ContainerGetMock.defaultExpectation.Counter, 1)
		mm_want := mmContainerGet.ContainerGetMock.defaultExpectation.params
		mm_got := ContainerMockContainerGetParams{cid}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmContainerGet.t.Errorf("ContainerMock.ContainerGet got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmContainerGet.ContainerGetMock.defaultExpectation.results
		if mm_results == nil {
			mmContainerGet.t.Fatal("No results are set for the ContainerMock.ContainerGet")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmContainerGet.funcContainerGet != nil {
		return mmContainerGet.funcContainerGet(cid)
	}
	mmContainerGet.t.Fatalf("Unexpected call to ContainerMock.ContainerGet. %v", cid)
	return
}

// ContainerGetAfterCounter returns a count of finished ContainerMock.ContainerGet invocations
func (mmContainerGet *ContainerMock) ContainerGetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainerGet.afterContainerGetCounter)
}

// ContainerGetBeforeCounter returns a count of ContainerMock.ContainerGet invocations
func (mmContainerGet *ContainerMock) ContainerGetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainerGet.beforeContainerGetCounter)
}

// Calls returns a list of arguments used in each call to ContainerMock.ContainerGet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmContainerGet *mContainerMockContainerGet) Calls() []*ContainerMockContainerGetParams {
	mmContainerGet.mutex.RLock()

	argCopy := make([]*ContainerMockContainerGetParams, len(mmContainerGet.callArgs))
	copy(argCopy, mmContainerGet.callArgs)

	mmContainerGet.mutex.RUnlock()

	return argCopy
}

// MinimockContainerGetDone returns true if the count of the ContainerGet invocations corresponds
// the number of defined expectations
func (m *ContainerMock) MinimockContainerGetDone() bool {
	for _, e := range m.ContainerGetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainerGetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainerGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainerGet != nil && mm_atomic.LoadUint64(&m.afterContainerGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockContainerGetInspect logs each unmet expectation
func (m *ContainerMock) MinimockContainerGetInspect() {
	for _, e := range m.ContainerGetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContainerMock.ContainerGet with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainerGetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainerGetCounter) < 1 {
		if m.ContainerGetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContainerMock.ContainerGet")
		} else {
			m.t.Errorf("Expected call to ContainerMock.ContainerGet with params: %#v", *m.ContainerGetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainerGet != nil && mm_atomic.LoadUint64(&m.afterContainerGetCounter) < 1 {
		m.t.Error("Expected call to ContainerMock.ContainerGet")
	}
}

type mContainerMockContainerGetAll struct {
	mock               *ContainerMock
	defaultExpectation *ContainerMockContainerGetAllExpectation
	expectations       []*ContainerMockContainerGetAllExpectation
}

// ContainerMockContainerGetAllExpectation specifies expectation struct of the Container.ContainerGetAll
type ContainerMockContainerGetAllExpectation struct {
	mock *ContainerMock

	results *ContainerMockContainerGetAllResults
	Counter uint64
}

// ContainerMockContainerGetAllResults contains results of the Container.ContainerGetAll
type ContainerMockContainerGetAllResults struct {
	cpa1 []*entity.Container
	err  error
}

// Expect sets up expected params for Container.ContainerGetAll
func (mmContainerGetAll *mContainerMockContainerGetAll) Expect() *mContainerMockContainerGetAll {
	if mmContainerGetAll.mock.funcContainerGetAll != nil {
		mmContainerGetAll.mock.t.Fatalf("ContainerMock.ContainerGetAll mock is already set by Set")
	}

	if mmContainerGetAll.defaultExpectation == nil {
		mmContainerGetAll.defaultExpectation = &ContainerMockContainerGetAllExpectation{}
	}

	return mmContainerGetAll
}

// Inspect accepts an inspector function that has same arguments as the Container.ContainerGetAll
func (mmContainerGetAll *mContainerMockContainerGetAll) Inspect(f func()) *mContainerMockContainerGetAll {
	if mmContainerGetAll.mock.inspectFuncContainerGetAll != nil {
		mmContainerGetAll.mock.t.Fatalf("Inspect function is already set for ContainerMock.ContainerGetAll")
	}

	mmContainerGetAll.mock.inspectFuncContainerGetAll = f

	return mmContainerGetAll
}

// Return sets up results that will be returned by Container.ContainerGetAll
func (mmContainerGetAll *mContainerMockContainerGetAll) Return(cpa1 []*entity.Container, err error) *ContainerMock {
	if mmContainerGetAll.mock.funcContainerGetAll != nil {
		mmContainerGetAll.mock.t.Fatalf("ContainerMock.ContainerGetAll mock is already set by Set")
	}

	if mmContainerGetAll.defaultExpectation == nil {
		mmContainerGetAll.defaultExpectation = &ContainerMockContainerGetAllExpectation{mock: mmContainerGetAll.mock}
	}
	mmContainerGetAll.defaultExpectation.results = &ContainerMockContainerGetAllResults{cpa1, err}
	return mmContainerGetAll.mock
}

//Set uses given function f to mock the Container.ContainerGetAll method
func (mmContainerGetAll *mContainerMockContainerGetAll) Set(f func() (cpa1 []*entity.Container, err error)) *ContainerMock {
	if mmContainerGetAll.defaultExpectation != nil {
		mmContainerGetAll.mock.t.Fatalf("Default expectation is already set for the Container.ContainerGetAll method")
	}

	if len(mmContainerGetAll.expectations) > 0 {
		mmContainerGetAll.mock.t.Fatalf("Some expectations are already set for the Container.ContainerGetAll method")
	}

	mmContainerGetAll.mock.funcContainerGetAll = f
	return mmContainerGetAll.mock
}

// ContainerGetAll implements containergateway.Container
func (mmContainerGetAll *ContainerMock) ContainerGetAll() (cpa1 []*entity.Container, err error) {
	mm_atomic.AddUint64(&mmContainerGetAll.beforeContainerGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmContainerGetAll.afterContainerGetAllCounter, 1)

	if mmContainerGetAll.inspectFuncContainerGetAll != nil {
		mmContainerGetAll.inspectFuncContainerGetAll()
	}

	if mmContainerGetAll.ContainerGetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmContainerGetAll.ContainerGetAllMock.defaultExpectation.Counter, 1)

		mm_results := mmContainerGetAll.ContainerGetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmContainerGetAll.t.Fatal("No results are set for the ContainerMock.ContainerGetAll")
		}
		return (*mm_results).cpa1, (*mm_results).err
	}
	if mmContainerGetAll.funcContainerGetAll != nil {
		return mmContainerGetAll.funcContainerGetAll()
	}
	mmContainerGetAll.t.Fatalf("Unexpected call to ContainerMock.ContainerGetAll.")
	return
}

// ContainerGetAllAfterCounter returns a count of finished ContainerMock.ContainerGetAll invocations
func (mmContainerGetAll *ContainerMock) ContainerGetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainerGetAll.afterContainerGetAllCounter)
}

// ContainerGetAllBeforeCounter returns a count of ContainerMock.ContainerGetAll invocations
func (mmContainerGetAll *ContainerMock) ContainerGetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainerGetAll.beforeContainerGetAllCounter)
}

// MinimockContainerGetAllDone returns true if the count of the ContainerGetAll invocations corresponds
// the number of defined expectations
func (m *ContainerMock) MinimockContainerGetAllDone() bool {
	for _, e := range m.ContainerGetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainerGetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainerGetAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainerGetAll != nil && mm_atomic.LoadUint64(&m.afterContainerGetAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockContainerGetAllInspect logs each unmet expectation
func (m *ContainerMock) MinimockContainerGetAllInspect() {
	for _, e := range m.ContainerGetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ContainerMock.ContainerGetAll")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainerGetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainerGetAllCounter) < 1 {
		m.t.Error("Expected call to ContainerMock.ContainerGetAll")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainerGetAll != nil && mm_atomic.LoadUint64(&m.afterContainerGetAllCounter) < 1 {
		m.t.Error("Expected call to ContainerMock.ContainerGetAll")
	}
}

type mContainerMockContainerKill struct {
	mock               *ContainerMock
	defaultExpectation *ContainerMockContainerKillExpectation
	expectations       []*ContainerMockContainerKillExpectation

	callArgs []*ContainerMockContainerKillParams
	mutex    sync.RWMutex
}

// ContainerMockContainerKillExpectation specifies expectation struct of the Container.ContainerKill
type ContainerMockContainerKillExpectation struct {
	mock    *ContainerMock
	params  *ContainerMockContainerKillParams
	results *ContainerMockContainerKillResults
	Counter uint64
}

// ContainerMockContainerKillParams contains parameters of the Container.ContainerKill
type ContainerMockContainerKillParams struct {
	c *entity.Container
}

// ContainerMockContainerKillResults contains results of the Container.ContainerKill
type ContainerMockContainerKillResults struct {
	err error
}

// Expect sets up expected params for Container.ContainerKill
func (mmContainerKill *mContainerMockContainerKill) Expect(c *entity.Container) *mContainerMockContainerKill {
	if mmContainerKill.mock.funcContainerKill != nil {
		mmContainerKill.mock.t.Fatalf("ContainerMock.ContainerKill mock is already set by Set")
	}

	if mmContainerKill.defaultExpectation == nil {
		mmContainerKill.defaultExpectation = &ContainerMockContainerKillExpectation{}
	}

	mmContainerKill.defaultExpectation.params = &ContainerMockContainerKillParams{c}
	for _, e := range mmContainerKill.expectations {
		if minimock.Equal(e.params, mmContainerKill.defaultExpectation.params) {
			mmContainerKill.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmContainerKill.defaultExpectation.params)
		}
	}

	return mmContainerKill
}

// Inspect accepts an inspector function that has same arguments as the Container.ContainerKill
func (mmContainerKill *mContainerMockContainerKill) Inspect(f func(c *entity.Container)) *mContainerMockContainerKill {
	if mmContainerKill.mock.inspectFuncContainerKill != nil {
		mmContainerKill.mock.t.Fatalf("Inspect function is already set for ContainerMock.ContainerKill")
	}

	mmContainerKill.mock.inspectFuncContainerKill = f

	return mmContainerKill
}

// Return sets up results that will be returned by Container.ContainerKill
func (mmContainerKill *mContainerMockContainerKill) Return(err error) *ContainerMock {
	if mmContainerKill.mock.funcContainerKill != nil {
		mmContainerKill.mock.t.Fatalf("ContainerMock.ContainerKill mock is already set by Set")
	}

	if mmContainerKill.defaultExpectation == nil {
		mmContainerKill.defaultExpectation = &ContainerMockContainerKillExpectation{mock: mmContainerKill.mock}
	}
	mmContainerKill.defaultExpectation.results = &ContainerMockContainerKillResults{err}
	return mmContainerKill.mock
}

//Set uses given function f to mock the Container.ContainerKill method
func (mmContainerKill *mContainerMockContainerKill) Set(f func(c *entity.Container) (err error)) *ContainerMock {
	if mmContainerKill.defaultExpectation != nil {
		mmContainerKill.mock.t.Fatalf("Default expectation is already set for the Container.ContainerKill method")
	}

	if len(mmContainerKill.expectations) > 0 {
		mmContainerKill.mock.t.Fatalf("Some expectations are already set for the Container.ContainerKill method")
	}

	mmContainerKill.mock.funcContainerKill = f
	return mmContainerKill.mock
}

// When sets expectation for the Container.ContainerKill which will trigger the result defined by the following
// Then helper
func (mmContainerKill *mContainerMockContainerKill) When(c *entity.Container) *ContainerMockContainerKillExpectation {
	if mmContainerKill.mock.funcContainerKill != nil {
		mmContainerKill.mock.t.Fatalf("ContainerMock.ContainerKill mock is already set by Set")
	}

	expectation := &ContainerMockContainerKillExpectation{
		mock:   mmContainerKill.mock,
		params: &ContainerMockContainerKillParams{c},
	}
	mmContainerKill.expectations = append(mmContainerKill.expectations, expectation)
	return expectation
}

// Then sets up Container.ContainerKill return parameters for the expectation previously defined by the When method
func (e *ContainerMockContainerKillExpectation) Then(err error) *ContainerMock {
	e.results = &ContainerMockContainerKillResults{err}
	return e.mock
}

// ContainerKill implements containergateway.Container
func (mmContainerKill *ContainerMock) ContainerKill(c *entity.Container) (err error) {
	mm_atomic.AddUint64(&mmContainerKill.beforeContainerKillCounter, 1)
	defer mm_atomic.AddUint64(&mmContainerKill.afterContainerKillCounter, 1)

	if mmContainerKill.inspectFuncContainerKill != nil {
		mmContainerKill.inspectFuncContainerKill(c)
	}

	mm_params := &ContainerMockContainerKillParams{c}

	// Record call args
	mmContainerKill.ContainerKillMock.mutex.Lock()
	mmContainerKill.ContainerKillMock.callArgs = append(mmContainerKill.ContainerKillMock.callArgs, mm_params)
	mmContainerKill.ContainerKillMock.mutex.Unlock()

	for _, e := range mmContainerKill.ContainerKillMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmContainerKill.ContainerKillMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmContainerKill.ContainerKillMock.defaultExpectation.Counter, 1)
		mm_want := mmContainerKill.ContainerKillMock.defaultExpectation.params
		mm_got := ContainerMockContainerKillParams{c}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmContainerKill.t.Errorf("ContainerMock.ContainerKill got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmContainerKill.ContainerKillMock.defaultExpectation.results
		if mm_results == nil {
			mmContainerKill.t.Fatal("No results are set for the ContainerMock.ContainerKill")
		}
		return (*mm_results).err
	}
	if mmContainerKill.funcContainerKill != nil {
		return mmContainerKill.funcContainerKill(c)
	}
	mmContainerKill.t.Fatalf("Unexpected call to ContainerMock.ContainerKill. %v", c)
	return
}

// ContainerKillAfterCounter returns a count of finished ContainerMock.ContainerKill invocations
func (mmContainerKill *ContainerMock) ContainerKillAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainerKill.afterContainerKillCounter)
}

// ContainerKillBeforeCounter returns a count of ContainerMock.ContainerKill invocations
func (mmContainerKill *ContainerMock) ContainerKillBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainerKill.beforeContainerKillCounter)
}

// Calls returns a list of arguments used in each call to ContainerMock.ContainerKill.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmContainerKill *mContainerMockContainerKill) Calls() []*ContainerMockContainerKillParams {
	mmContainerKill.mutex.RLock()

	argCopy := make([]*ContainerMockContainerKillParams, len(mmContainerKill.callArgs))
	copy(argCopy, mmContainerKill.callArgs)

	mmContainerKill.mutex.RUnlock()

	return argCopy
}

// MinimockContainerKillDone returns true if the count of the ContainerKill invocations corresponds
// the number of defined expectations
func (m *ContainerMock) MinimockContainerKillDone() bool {
	for _, e := range m.ContainerKillMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainerKillMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainerKillCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainerKill != nil && mm_atomic.LoadUint64(&m.afterContainerKillCounter) < 1 {
		return false
	}
	return true
}

// MinimockContainerKillInspect logs each unmet expectation
func (m *ContainerMock) MinimockContainerKillInspect() {
	for _, e := range m.ContainerKillMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContainerMock.ContainerKill with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainerKillMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainerKillCounter) < 1 {
		if m.ContainerKillMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContainerMock.ContainerKill")
		} else {
			m.t.Errorf("Expected call to ContainerMock.ContainerKill with params: %#v", *m.ContainerKillMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainerKill != nil && mm_atomic.LoadUint64(&m.afterContainerKillCounter) < 1 {
		m.t.Error("Expected call to ContainerMock.ContainerKill")
	}
}

type mContainerMockContainerRefresh struct {
	mock               *ContainerMock
	defaultExpectation *ContainerMockContainerRefreshExpectation
	expectations       []*ContainerMockContainerRefreshExpectation

	callArgs []*ContainerMockContainerRefreshParams
	mutex    sync.RWMutex
}

// ContainerMockContainerRefreshExpectation specifies expectation struct of the Container.ContainerRefresh
type ContainerMockContainerRefreshExpectation struct {
	mock    *ContainerMock
	params  *ContainerMockContainerRefreshParams
	results *ContainerMockContainerRefreshResults
	Counter uint64
}

// ContainerMockContainerRefreshParams contains parameters of the Container.ContainerRefresh
type ContainerMockContainerRefreshParams struct {
	c *entity.Container
}

// ContainerMockContainerRefreshResults contains results of the Container.ContainerRefresh
type ContainerMockContainerRefreshResults struct {
	err error
}

// Expect sets up expected params for Container.ContainerRefresh
func (mmContainerRefresh *mContainerMockContainerRefresh) Expect(c *entity.Container) *mContainerMockContainerRefresh {
	if mmContainerRefresh.mock.funcContainerRefresh != nil {
		mmContainerRefresh.mock.t.Fatalf("ContainerMock.ContainerRefresh mock is already set by Set")
	}

	if mmContainerRefresh.defaultExpectation == nil {
		mmContainerRefresh.defaultExpectation = &ContainerMockContainerRefreshExpectation{}
	}

	mmContainerRefresh.defaultExpectation.params = &ContainerMockContainerRefreshParams{c}
	for _, e := range mmContainerRefresh.expectations {
		if minimock.Equal(e.params, mmContainerRefresh.defaultExpectation.params) {
			mmContainerRefresh.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmContainerRefresh.defaultExpectation.params)
		}
	}

	return mmContainerRefresh
}

// Inspect accepts an inspector function that has same arguments as the Container.ContainerRefresh
func (mmContainerRefresh *mContainerMockContainerRefresh) Inspect(f func(c *entity.Container)) *mContainerMockContainerRefresh {
	if mmContainerRefresh.mock.inspectFuncContainerRefresh != nil {
		mmContainerRefresh.mock.t.Fatalf("Inspect function is already set for ContainerMock.ContainerRefresh")
	}

	mmContainerRefresh.mock.inspectFuncContainerRefresh = f

	return mmContainerRefresh
}

// Return sets up results that will be returned by Container.ContainerRefresh
func (mmContainerRefresh *mContainerMockContainerRefresh) Return(err error) *ContainerMock {
	if mmContainerRefresh.mock.funcContainerRefresh != nil {
		mmContainerRefresh.mock.t.Fatalf("ContainerMock.ContainerRefresh mock is already set by Set")
	}

	if mmContainerRefresh.defaultExpectation == nil {
		mmContainerRefresh.defaultExpectation = &ContainerMockContainerRefreshExpectation{mock: mmContainerRefresh.mock}
	}
	mmContainerRefresh.defaultExpectation.results = &ContainerMockContainerRefreshResults{err}
	return mmContainerRefresh.mock
}

//Set uses given function f to mock the Container.ContainerRefresh method
func (mmContainerRefresh *mContainerMockContainerRefresh) Set(f func(c *entity.Container) (err error)) *ContainerMock {
	if mmContainerRefresh.defaultExpectation != nil {
		mmContainerRefresh.mock.t.Fatalf("Default expectation is already set for the Container.ContainerRefresh method")
	}

	if len(mmContainerRefresh.expectations) > 0 {
		mmContainerRefresh.mock.t.Fatalf("Some expectations are already set for the Container.ContainerRefresh method")
	}

	mmContainerRefresh.mock.funcContainerRefresh = f
	return mmContainerRefresh.mock
}

// When sets expectation for the Container.ContainerRefresh which will trigger the result defined by the following
// Then helper
func (mmContainerRefresh *mContainerMockContainerRefresh) When(c *entity.Container) *ContainerMockContainerRefreshExpectation {
	if mmContainerRefresh.mock.funcContainerRefresh != nil {
		mmContainerRefresh.mock.t.Fatalf("ContainerMock.ContainerRefresh mock is already set by Set")
	}

	expectation := &ContainerMockContainerRefreshExpectation{
		mock:   mmContainerRefresh.mock,
		params: &ContainerMockContainerRefreshParams{c},
	}
	mmContainerRefresh.expectations = append(mmContainerRefresh.expectations, expectation)
	return expectation
}

// Then sets up Container.ContainerRefresh return parameters for the expectation previously defined by the When method
func (e *ContainerMockContainerRefreshExpectation) Then(err error) *ContainerMock {
	e.results = &ContainerMockContainerRefreshResults{err}
	return e.mock
}

// ContainerRefresh implements containergateway.Container
func (mmContainerRefresh *ContainerMock) ContainerRefresh(c *entity.Container) (err error) {
	mm_atomic.AddUint64(&mmContainerRefresh.beforeContainerRefreshCounter, 1)
	defer mm_atomic.AddUint64(&mmContainerRefresh.afterContainerRefreshCounter, 1)

	if mmContainerRefresh.inspectFuncContainerRefresh != nil {
		mmContainerRefresh.inspectFuncContainerRefresh(c)
	}

	mm_params := &ContainerMockContainerRefreshParams{c}

	// Record call args
	mmContainerRefresh.ContainerRefreshMock.mutex.Lock()
	mmContainerRefresh.ContainerRefreshMock.callArgs = append(mmContainerRefresh.ContainerRefreshMock.callArgs, mm_params)
	mmContainerRefresh.ContainerRefreshMock.mutex.Unlock()

	for _, e := range mmContainerRefresh.ContainerRefreshMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmContainerRefresh.ContainerRefreshMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmContainerRefresh.ContainerRefreshMock.defaultExpectation.Counter, 1)
		mm_want := mmContainerRefresh.ContainerRefreshMock.defaultExpectation.params
		mm_got := ContainerMockContainerRefreshParams{c}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmContainerRefresh.t.Errorf("ContainerMock.ContainerRefresh got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmContainerRefresh.ContainerRefreshMock.defaultExpectation.results
		if mm_results == nil {
			mmContainerRefresh.t.Fatal("No results are set for the ContainerMock.ContainerRefresh")
		}
		return (*mm_results).err
	}
	if mmContainerRefresh.funcContainerRefresh != nil {
		return mmContainerRefresh.funcContainerRefresh(c)
	}
	mmContainerRefresh.t.Fatalf("Unexpected call to ContainerMock.ContainerRefresh. %v", c)
	return
}

// ContainerRefreshAfterCounter returns a count of finished ContainerMock.ContainerRefresh invocations
func (mmContainerRefresh *ContainerMock) ContainerRefreshAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainerRefresh.afterContainerRefreshCounter)
}

// ContainerRefreshBeforeCounter returns a count of ContainerMock.ContainerRefresh invocations
func (mmContainerRefresh *ContainerMock) ContainerRefreshBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainerRefresh.beforeContainerRefreshCounter)
}

// Calls returns a list of arguments used in each call to ContainerMock.ContainerRefresh.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmContainerRefresh *mContainerMockContainerRefresh) Calls() []*ContainerMockContainerRefreshParams {
	mmContainerRefresh.mutex.RLock()

	argCopy := make([]*ContainerMockContainerRefreshParams, len(mmContainerRefresh.callArgs))
	copy(argCopy, mmContainerRefresh.callArgs)

	mmContainerRefresh.mutex.RUnlock()

	return argCopy
}

// MinimockContainerRefreshDone returns true if the count of the ContainerRefresh invocations corresponds
// the number of defined expectations
func (m *ContainerMock) MinimockContainerRefreshDone() bool {
	for _, e := range m.ContainerRefreshMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainerRefreshMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainerRefreshCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainerRefresh != nil && mm_atomic.LoadUint64(&m.afterContainerRefreshCounter) < 1 {
		return false
	}
	return true
}

// MinimockContainerRefreshInspect logs each unmet expectation
func (m *ContainerMock) MinimockContainerRefreshInspect() {
	for _, e := range m.ContainerRefreshMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContainerMock.ContainerRefresh with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainerRefreshMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainerRefreshCounter) < 1 {
		if m.ContainerRefreshMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContainerMock.ContainerRefresh")
		} else {
			m.t.Errorf("Expected call to ContainerMock.ContainerRefresh with params: %#v", *m.ContainerRefreshMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainerRefresh != nil && mm_atomic.LoadUint64(&m.afterContainerRefreshCounter) < 1 {
		m.t.Error("Expected call to ContainerMock.ContainerRefresh")
	}
}

type mContainerMockContainerRemove struct {
	mock               *ContainerMock
	defaultExpectation *ContainerMockContainerRemoveExpectation
	expectations       []*ContainerMockContainerRemoveExpectation

	callArgs []*ContainerMockContainerRemoveParams
	mutex    sync.RWMutex
}

// ContainerMockContainerRemoveExpectation specifies expectation struct of the Container.ContainerRemove
type ContainerMockContainerRemoveExpectation struct {
	mock    *ContainerMock
	params  *ContainerMockContainerRemoveParams
	results *ContainerMockContainerRemoveResults
	Counter uint64
}

// ContainerMockContainerRemoveParams contains parameters of the Container.ContainerRemove
type ContainerMockContainerRemoveParams struct {
	c *entity.Container
}

// ContainerMockContainerRemoveResults contains results of the Container.ContainerRemove
type ContainerMockContainerRemoveResults struct {
	err error
}

// Expect sets up expected params for Container.ContainerRemove
func (mmContainerRemove *mContainerMockContainerRemove) Expect(c *entity.Container) *mContainerMockContainerRemove {
	if mmContainerRemove.mock.funcContainerRemove != nil {
		mmContainerRemove.mock.t.Fatalf("ContainerMock.ContainerRemove mock is already set by Set")
	}

	if mmContainerRemove.defaultExpectation == nil {
		mmContainerRemove.defaultExpectation = &ContainerMockContainerRemoveExpectation{}
	}

	mmContainerRemove.defaultExpectation.params = &ContainerMockContainerRemoveParams{c}
	for _, e := range mmContainerRemove.expectations {
		if minimock.Equal(e.params, mmContainerRemove.defaultExpectation.params) {
			mmContainerRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmContainerRemove.defaultExpectation.params)
		}
	}

	return mmContainerRemove
}

// Inspect accepts an inspector function that has same arguments as the Container.ContainerRemove
func (mmContainerRemove *mContainerMockContainerRemove) Inspect(f func(c *entity.Container)) *mContainerMockContainerRemove {
	if mmContainerRemove.mock.inspectFuncContainerRemove != nil {
		mmContainerRemove.mock.t.Fatalf("Inspect function is already set for ContainerMock.ContainerRemove")
	}

	mmContainerRemove.mock.inspectFuncContainerRemove = f

	return mmContainerRemove
}

// Return sets up results that will be returned by Container.ContainerRemove
func (mmContainerRemove *mContainerMockContainerRemove) Return(err error) *ContainerMock {
	if mmContainerRemove.mock.funcContainerRemove != nil {
		mmContainerRemove.mock.t.Fatalf("ContainerMock.ContainerRemove mock is already set by Set")
	}

	if mmContainerRemove.defaultExpectation == nil {
		mmContainerRemove.defaultExpectation = &ContainerMockContainerRemoveExpectation{mock: mmContainerRemove.mock}
	}
	mmContainerRemove.defaultExpectation.results = &ContainerMockContainerRemoveResults{err}
	return mmContainerRemove.mock
}

//Set uses given function f to mock the Container.ContainerRemove method
func (mmContainerRemove *mContainerMockContainerRemove) Set(f func(c *entity.Container) (err error)) *ContainerMock {
	if mmContainerRemove.defaultExpectation != nil {
		mmContainerRemove.mock.t.Fatalf("Default expectation is already set for the Container.ContainerRemove method")
	}

	if len(mmContainerRemove.expectations) > 0 {
		mmContainerRemove.mock.t.Fatalf("Some expectations are already set for the Container.ContainerRemove method")
	}

	mmContainerRemove.mock.funcContainerRemove = f
	return mmContainerRemove.mock
}

// When sets expectation for the Container.ContainerRemove which will trigger the result defined by the following
// Then helper
func (mmContainerRemove *mContainerMockContainerRemove) When(c *entity.Container) *ContainerMockContainerRemoveExpectation {
	if mmContainerRemove.mock.funcContainerRemove != nil {
		mmContainerRemove.mock.t.Fatalf("ContainerMock.ContainerRemove mock is already set by Set")
	}

	expectation := &ContainerMockContainerRemoveExpectation{
		mock:   mmContainerRemove.mock,
		params: &ContainerMockContainerRemoveParams{c},
	}
	mmContainerRemove.expectations = append(mmContainerRemove.expectations, expectation)
	return expectation
}

// Then sets up Container.ContainerRemove return parameters for the expectation previously defined by the When method
func (e *ContainerMockContainerRemoveExpectation) Then(err error) *ContainerMock {
	e.results = &ContainerMockContainerRemoveResults{err}
	return e.mock
}

// ContainerRemove implements containergateway.Container
func (mmContainerRemove *ContainerMock) ContainerRemove(c *entity.Container) (err error) {
	mm_atomic.AddUint64(&mmContainerRemove.beforeContainerRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmContainerRemove.afterContainerRemoveCounter, 1)

	if mmContainerRemove.inspectFuncContainerRemove != nil {
		mmContainerRemove.inspectFuncContainerRemove(c)
	}

	mm_params := &ContainerMockContainerRemoveParams{c}

	// Record call args
	mmContainerRemove.ContainerRemoveMock.mutex.Lock()
	mmContainerRemove.ContainerRemoveMock.callArgs = append(mmContainerRemove.ContainerRemoveMock.callArgs, mm_params)
	mmContainerRemove.ContainerRemoveMock.mutex.Unlock()

	for _, e := range mmContainerRemove.ContainerRemoveMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmContainerRemove.ContainerRemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmContainerRemove.ContainerRemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmContainerRemove.ContainerRemoveMock.defaultExpectation.params
		mm_got := ContainerMockContainerRemoveParams{c}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmContainerRemove.t.Errorf("ContainerMock.ContainerRemove got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmContainerRemove.ContainerRemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmContainerRemove.t.Fatal("No results are set for the ContainerMock.ContainerRemove")
		}
		return (*mm_results).err
	}
	if mmContainerRemove.funcContainerRemove != nil {
		return mmContainerRemove.funcContainerRemove(c)
	}
	mmContainerRemove.t.Fatalf("Unexpected call to ContainerMock.ContainerRemove. %v", c)
	return
}

// ContainerRemoveAfterCounter returns a count of finished ContainerMock.ContainerRemove invocations
func (mmContainerRemove *ContainerMock) ContainerRemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainerRemove.afterContainerRemoveCounter)
}

// ContainerRemoveBeforeCounter returns a count of ContainerMock.ContainerRemove invocations
func (mmContainerRemove *ContainerMock) ContainerRemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainerRemove.beforeContainerRemoveCounter)
}

// Calls returns a list of arguments used in each call to ContainerMock.ContainerRemove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmContainerRemove *mContainerMockContainerRemove) Calls() []*ContainerMockContainerRemoveParams {
	mmContainerRemove.mutex.RLock()

	argCopy := make([]*ContainerMockContainerRemoveParams, len(mmContainerRemove.callArgs))
	copy(argCopy, mmContainerRemove.callArgs)

	mmContainerRemove.mutex.RUnlock()

	return argCopy
}

// MinimockContainerRemoveDone returns true if the count of the ContainerRemove invocations corresponds
// the number of defined expectations
func (m *ContainerMock) MinimockContainerRemoveDone() bool {
	for _, e := range m.ContainerRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainerRemoveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainerRemoveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainerRemove != nil && mm_atomic.LoadUint64(&m.afterContainerRemoveCounter) < 1 {
		return false
	}
	return true
}

// MinimockContainerRemoveInspect logs each unmet expectation
func (m *ContainerMock) MinimockContainerRemoveInspect() {
	for _, e := range m.ContainerRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContainerMock.ContainerRemove with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainerRemoveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainerRemoveCounter) < 1 {
		if m.ContainerRemoveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContainerMock.ContainerRemove")
		} else {
			m.t.Errorf("Expected call to ContainerMock.ContainerRemove with params: %#v", *m.ContainerRemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainerRemove != nil && mm_atomic.LoadUint64(&m.afterContainerRemoveCounter) < 1 {
		m.t.Error("Expected call to ContainerMock.ContainerRemove")
	}
}

type mContainerMockContainerRestart struct {
	mock               *ContainerMock
	defaultExpectation *ContainerMockContainerRestartExpectation
	expectations       []*ContainerMockContainerRestartExpectation

	callArgs []*ContainerMockContainerRestartParams
	mutex    sync.RWMutex
}

// ContainerMockContainerRestartExpectation specifies expectation struct of the Container.ContainerRestart
type ContainerMockContainerRestartExpectation struct {
	mock    *ContainerMock
	params  *ContainerMockContainerRestartParams
	results *ContainerMockContainerRestartResults
	Counter uint64
}

// ContainerMockContainerRestartParams contains parameters of the Container.ContainerRestart
type ContainerMockContainerRestartParams struct {
	c *entity.Container
}

// ContainerMockContainerRestartResults contains results of the Container.ContainerRestart
type ContainerMockContainerRestartResults struct {
	err error
}

// Expect sets up expected params for Container.ContainerRestart
func (mmContainerRestart *mContainerMockContainerRestart) Expect(c *entity.Container) *mContainerMockContainerRestart {
	if mmContainerRestart.mock.funcContainerRestart != nil {
		mmContainerRestart.mock.t.Fatalf("ContainerMock.ContainerRestart mock is already set by Set")
	}

	if mmContainerRestart.defaultExpectation == nil {
		mmContainerRestart.defaultExpectation = &ContainerMockContainerRestartExpectation{}
	}

	mmContainerRestart.defaultExpectation.params = &ContainerMockContainerRestartParams{c}
	for _, e := range mmContainerRestart.expectations {
		if minimock.Equal(e.params, mmContainerRestart.defaultExpectation.params) {
			mmContainerRestart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmContainerRestart.defaultExpectation.params)
		}
	}

	return mmContainerRestart
}

// Inspect accepts an inspector function that has same arguments as the Container.ContainerRestart
func (mmContainerRestart *mContainerMockContainerRestart) Inspect(f func(c *entity.Container)) *mContainerMockContainerRestart {
	if mmContainerRestart.mock.inspectFuncContainerRestart != nil {
		mmContainerRestart.mock.t.Fatalf("Inspect function is already set for ContainerMock.ContainerRestart")
	}

	mmContainerRestart.mock.inspectFuncContainerRestart = f

	return mmContainerRestart
}

// Return sets up results that will be returned by Container.ContainerRestart
func (mmContainerRestart *mContainerMockContainerRestart) Return(err error) *ContainerMock {
	if mmContainerRestart.mock.funcContainerRestart != nil {
		mmContainerRestart.mock.t.Fatalf("ContainerMock.ContainerRestart mock is already set by Set")
	}

	if mmContainerRestart.defaultExpectation == nil {
		mmContainerRestart.defaultExpectation = &ContainerMockContainerRestartExpectation{mock: mmContainerRestart.mock}
	}
	mmContainerRestart.defaultExpectation.results = &ContainerMockContainerRestartResults{err}
	return mmContainerRestart.mock
}

//Set uses given function f to mock the Container.ContainerRestart method
func (mmContainerRestart *mContainerMockContainerRestart) Set(f func(c *entity.Container) (err error)) *ContainerMock {
	if mmContainerRestart.defaultExpectation != nil {
		mmContainerRestart.mock.t.Fatalf("Default expectation is already set for the Container.ContainerRestart method")
	}

	if len(mmContainerRestart.expectations) > 0 {
		mmContainerRestart.mock.t.Fatalf("Some expectations are already set for the Container.ContainerRestart method")
	}

	mmContainerRestart.mock.funcContainerRestart = f
	return mmContainerRestart.mock
}

// When sets expectation for the Container.ContainerRestart which will trigger the result defined by the following
// Then helper
func (mmContainerRestart *mContainerMockContainerRestart) When(c *entity.Container) *ContainerMockContainerRestartExpectation {
	if mmContainerRestart.mock.funcContainerRestart != nil {
		mmContainerRestart.mock.t.Fatalf("ContainerMock.ContainerRestart mock is already set by Set")
	}

	expectation := &ContainerMockContainerRestartExpectation{
		mock:   mmContainerRestart.mock,
		params: &ContainerMockContainerRestartParams{c},
	}
	mmContainerRestart.expectations = append(mmContainerRestart.expectations, expectation)
	return expectation
}

// Then sets up Container.ContainerRestart return parameters for the expectation previously defined by the When method
func (e *ContainerMockContainerRestartExpectation) Then(err error) *ContainerMock {
	e.results = &ContainerMockContainerRestartResults{err}
	return e.mock
}

// ContainerRestart implements containergateway.Container
func (mmContainerRestart *ContainerMock) ContainerRestart(c *entity.Container) (err error) {
	mm_atomic.AddUint64(&mmContainerRestart.beforeContainerRestartCounter, 1)
	defer mm_atomic.AddUint64(&mmContainerRestart.afterContainerRestartCounter, 1)

	if mmContainerRestart.inspectFuncContainerRestart != nil {
		mmContainerRestart.inspectFuncContainerRestart(c)
	}

	mm_params := &ContainerMockContainerRestartParams{c}

	// Record call args
	mmContainerRestart.ContainerRestartMock.mutex.Lock()
	mmContainerRestart.ContainerRestartMock.callArgs = append(mmContainerRestart.ContainerRestartMock.callArgs, mm_params)
	mmContainerRestart.ContainerRestartMock.mutex.Unlock()

	for _, e := range mmContainerRestart.ContainerRestartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmContainerRestart.ContainerRestartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmContainerRestart.ContainerRestartMock.defaultExpectation.Counter, 1)
		mm_want := mmContainerRestart.ContainerRestartMock.defaultExpectation.params
		mm_got := ContainerMockContainerRestartParams{c}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmContainerRestart.t.Errorf("ContainerMock.ContainerRestart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmContainerRestart.ContainerRestartMock.defaultExpectation.results
		if mm_results == nil {
			mmContainerRestart.t.Fatal("No results are set for the ContainerMock.ContainerRestart")
		}
		return (*mm_results).err
	}
	if mmContainerRestart.funcContainerRestart != nil {
		return mmContainerRestart.funcContainerRestart(c)
	}
	mmContainerRestart.t.Fatalf("Unexpected call to ContainerMock.ContainerRestart. %v", c)
	return
}

// ContainerRestartAfterCounter returns a count of finished ContainerMock.ContainerRestart invocations
func (mmContainerRestart *ContainerMock) ContainerRestartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainerRestart.afterContainerRestartCounter)
}

// ContainerRestartBeforeCounter returns a count of ContainerMock.ContainerRestart invocations
func (mmContainerRestart *ContainerMock) ContainerRestartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainerRestart.beforeContainerRestartCounter)
}

// Calls returns a list of arguments used in each call to ContainerMock.ContainerRestart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmContainerRestart *mContainerMockContainerRestart) Calls() []*ContainerMockContainerRestartParams {
	mmContainerRestart.mutex.RLock()

	argCopy := make([]*ContainerMockContainerRestartParams, len(mmContainerRestart.callArgs))
	copy(argCopy, mmContainerRestart.callArgs)

	mmContainerRestart.mutex.RUnlock()

	return argCopy
}

// MinimockContainerRestartDone returns true if the count of the ContainerRestart invocations corresponds
// the number of defined expectations
func (m *ContainerMock) MinimockContainerRestartDone() bool {
	for _, e := range m.ContainerRestartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainerRestartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainerRestartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainerRestart != nil && mm_atomic.LoadUint64(&m.afterContainerRestartCounter) < 1 {
		return false
	}
	return true
}

// MinimockContainerRestartInspect logs each unmet expectation
func (m *ContainerMock) MinimockContainerRestartInspect() {
	for _, e := range m.ContainerRestartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContainerMock.ContainerRestart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainerRestartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainerRestartCounter) < 1 {
		if m.ContainerRestartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContainerMock.ContainerRestart")
		} else {
			m.t.Errorf("Expected call to ContainerMock.ContainerRestart with params: %#v", *m.ContainerRestartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainerRestart != nil && mm_atomic.LoadUint64(&m.afterContainerRestartCounter) < 1 {
		m.t.Error("Expected call to ContainerMock.ContainerRestart")
	}
}

type mContainerMockContainerRun struct {
	mock               *ContainerMock
	defaultExpectation *ContainerMockContainerRunExpectation
	expectations       []*ContainerMockContainerRunExpectation

	callArgs []*ContainerMockContainerRunParams
	mutex    sync.RWMutex
}

// ContainerMockContainerRunExpectation specifies expectation struct of the Container.ContainerRun
type ContainerMockContainerRunExpectation struct {
	mock    *ContainerMock
	params  *ContainerMockContainerRunParams
	results *ContainerMockContainerRunResults
	Counter uint64
}

// ContainerMockContainerRunParams contains parameters of the Container.ContainerRun
type ContainerMockContainerRunParams struct {
	c *entity.Container
}

// ContainerMockContainerRunResults contains results of the Container.ContainerRun
type ContainerMockContainerRunResults struct {
	err error
}

// Expect sets up expected params for Container.ContainerRun
func (mmContainerRun *mContainerMockContainerRun) Expect(c *entity.Container) *mContainerMockContainerRun {
	if mmContainerRun.mock.funcContainerRun != nil {
		mmContainerRun.mock.t.Fatalf("ContainerMock.ContainerRun mock is already set by Set")
	}

	if mmContainerRun.defaultExpectation == nil {
		mmContainerRun.defaultExpectation = &ContainerMockContainerRunExpectation{}
	}

	mmContainerRun.defaultExpectation.params = &ContainerMockContainerRunParams{c}
	for _, e := range mmContainerRun.expectations {
		if minimock.Equal(e.params, mmContainerRun.defaultExpectation.params) {
			mmContainerRun.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmContainerRun.defaultExpectation.params)
		}
	}

	return mmContainerRun
}

// Inspect accepts an inspector function that has same arguments as the Container.ContainerRun
func (mmContainerRun *mContainerMockContainerRun) Inspect(f func(c *entity.Container)) *mContainerMockContainerRun {
	if mmContainerRun.mock.inspectFuncContainerRun != nil {
		mmContainerRun.mock.t.Fatalf("Inspect function is already set for ContainerMock.ContainerRun")
	}

	mmContainerRun.mock.inspectFuncContainerRun = f

	return mmContainerRun
}

// Return sets up results that will be returned by Container.ContainerRun
func (mmContainerRun *mContainerMockContainerRun) Return(err error) *ContainerMock {
	if mmContainerRun.mock.funcContainerRun != nil {
		mmContainerRun.mock.t.Fatalf("ContainerMock.ContainerRun mock is already set by Set")
	}

	if mmContainerRun.defaultExpectation == nil {
		mmContainerRun.defaultExpectation = &ContainerMockContainerRunExpectation{mock: mmContainerRun.mock}
	}
	mmContainerRun.defaultExpectation.results = &ContainerMockContainerRunResults{err}
	return mmContainerRun.mock
}

//Set uses given function f to mock the Container.ContainerRun method
func (mmContainerRun *mContainerMockContainerRun) Set(f func(c *entity.Container) (err error)) *ContainerMock {
	if mmContainerRun.defaultExpectation != nil {
		mmContainerRun.mock.t.Fatalf("Default expectation is already set for the Container.ContainerRun method")
	}

	if len(mmContainerRun.expectations) > 0 {
		mmContainerRun.mock.t.Fatalf("Some expectations are already set for the Container.ContainerRun method")
	}

	mmContainerRun.mock.funcContainerRun = f
	return mmContainerRun.mock
}

// When sets expectation for the Container.ContainerRun which will trigger the result defined by the following
// Then helper
func (mmContainerRun *mContainerMockContainerRun) When(c *entity.Container) *ContainerMockContainerRunExpectation {
	if mmContainerRun.mock.funcContainerRun != nil {
		mmContainerRun.mock.t.Fatalf("ContainerMock.ContainerRun mock is already set by Set")
	}

	expectation := &ContainerMockContainerRunExpectation{
		mock:   mmContainerRun.mock,
		params: &ContainerMockContainerRunParams{c},
	}
	mmContainerRun.expectations = append(mmContainerRun.expectations, expectation)
	return expectation
}

// Then sets up Container.ContainerRun return parameters for the expectation previously defined by the When method
func (e *ContainerMockContainerRunExpectation) Then(err error) *ContainerMock {
	e.results = &ContainerMockContainerRunResults{err}
	return e.mock
}

// ContainerRun implements containergateway.Container
func (mmContainerRun *ContainerMock) ContainerRun(c *entity.Container) (err error) {
	mm_atomic.AddUint64(&mmContainerRun.beforeContainerRunCounter, 1)
	defer mm_atomic.AddUint64(&mmContainerRun.afterContainerRunCounter, 1)

	if mmContainerRun.inspectFuncContainerRun != nil {
		mmContainerRun.inspectFuncContainerRun(c)
	}

	mm_params := &ContainerMockContainerRunParams{c}

	// Record call args
	mmContainerRun.ContainerRunMock.mutex.Lock()
	mmContainerRun.ContainerRunMock.callArgs = append(mmContainerRun.ContainerRunMock.callArgs, mm_params)
	mmContainerRun.ContainerRunMock.mutex.Unlock()

	for _, e := range mmContainerRun.ContainerRunMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmContainerRun.ContainerRunMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmContainerRun.ContainerRunMock.defaultExpectation.Counter, 1)
		mm_want := mmContainerRun.ContainerRunMock.defaultExpectation.params
		mm_got := ContainerMockContainerRunParams{c}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmContainerRun.t.Errorf("ContainerMock.ContainerRun got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmContainerRun.ContainerRunMock.defaultExpectation.results
		if mm_results == nil {
			mmContainerRun.t.Fatal("No results are set for the ContainerMock.ContainerRun")
		}
		return (*mm_results).err
	}
	if mmContainerRun.funcContainerRun != nil {
		return mmContainerRun.funcContainerRun(c)
	}
	mmContainerRun.t.Fatalf("Unexpected call to ContainerMock.ContainerRun. %v", c)
	return
}

// ContainerRunAfterCounter returns a count of finished ContainerMock.ContainerRun invocations
func (mmContainerRun *ContainerMock) ContainerRunAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainerRun.afterContainerRunCounter)
}

// ContainerRunBeforeCounter returns a count of ContainerMock.ContainerRun invocations
func (mmContainerRun *ContainerMock) ContainerRunBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainerRun.beforeContainerRunCounter)
}

// Calls returns a list of arguments used in each call to ContainerMock.ContainerRun.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmContainerRun *mContainerMockContainerRun) Calls() []*ContainerMockContainerRunParams {
	mmContainerRun.mutex.RLock()

	argCopy := make([]*ContainerMockContainerRunParams, len(mmContainerRun.callArgs))
	copy(argCopy, mmContainerRun.callArgs)

	mmContainerRun.mutex.RUnlock()

	return argCopy
}

// MinimockContainerRunDone returns true if the count of the ContainerRun invocations corresponds
// the number of defined expectations
func (m *ContainerMock) MinimockContainerRunDone() bool {
	for _, e := range m.ContainerRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainerRunMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainerRunCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainerRun != nil && mm_atomic.LoadUint64(&m.afterContainerRunCounter) < 1 {
		return false
	}
	return true
}

// MinimockContainerRunInspect logs each unmet expectation
func (m *ContainerMock) MinimockContainerRunInspect() {
	for _, e := range m.ContainerRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContainerMock.ContainerRun with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainerRunMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainerRunCounter) < 1 {
		if m.ContainerRunMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContainerMock.ContainerRun")
		} else {
			m.t.Errorf("Expected call to ContainerMock.ContainerRun with params: %#v", *m.ContainerRunMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainerRun != nil && mm_atomic.LoadUint64(&m.afterContainerRunCounter) < 1 {
		m.t.Error("Expected call to ContainerMock.ContainerRun")
	}
}

type mContainerMockContainerStats struct {
	mock               *ContainerMock
	defaultExpectation *ContainerMockContainerStatsExpectation
	expectations       []*ContainerMockContainerStatsExpectation

	callArgs []*ContainerMockContainerStatsParams
	mutex    sync.RWMutex
}

// ContainerMockContainerStatsExpectation specifies expectation struct of the Container.ContainerStats
type ContainerMockContainerStatsExpectation struct {
	mock    *ContainerMock
	params  *ContainerMockContainerStatsParams
	results *ContainerMockContainerStatsResults
	Counter uint64
}

// ContainerMockContainerStatsParams contains parameters of the Container.ContainerStats
type ContainerMockContainerStatsParams struct {
	cid string
}

// ContainerMockContainerStatsResults contains results of the Container.ContainerStats
type ContainerMockContainerStatsResults struct {
	sp1 *entity.Stat
	err error
}

// Expect sets up expected params for Container.ContainerStats
func (mmContainerStats *mContainerMockContainerStats) Expect(cid string) *mContainerMockContainerStats {
	if mmContainerStats.mock.funcContainerStats != nil {
		mmContainerStats.mock.t.Fatalf("ContainerMock.ContainerStats mock is already set by Set")
	}

	if mmContainerStats.defaultExpectation == nil {
		mmContainerStats.defaultExpectation = &ContainerMockContainerStatsExpectation{}
	}

	mmContainerStats.defaultExpectation.params = &ContainerMockContainerStatsParams{cid}
	for _, e := range mmContainerStats.expectations {
		if minimock.Equal(e.params, mmContainerStats.defaultExpectation.params) {
			mmContainerStats.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmContainerStats.defaultExpectation.params)
		}
	}

	return mmContainerStats
}

// Inspect accepts an inspector function that has same arguments as the Container.ContainerStats
func (mmContainerStats *mContainerMockContainerStats) Inspect(f func(cid string)) *mContainerMockContainerStats {
	if mmContainerStats.mock.inspectFuncContainerStats != nil {
		mmContainerStats.mock.t.Fatalf("Inspect function is already set for ContainerMock.ContainerStats")
	}

	mmContainerStats.mock.inspectFuncContainerStats = f

	return mmContainerStats
}

// Return sets up results that will be returned by Container.ContainerStats
func (mmContainerStats *mContainerMockContainerStats) Return(sp1 *entity.Stat, err error) *ContainerMock {
	if mmContainerStats.mock.funcContainerStats != nil {
		mmContainerStats.mock.t.Fatalf("ContainerMock.ContainerStats mock is already set by Set")
	}

	if mmContainerStats.defaultExpectation == nil {
		mmContainerStats.defaultExpectation = &ContainerMockContainerStatsExpectation{mock: mmContainerStats.mock}
	}
	mmContainerStats.defaultExpectation.results = &ContainerMockContainerStatsResults{sp1, err}
	return mmContainerStats.mock
}

//Set uses given function f to mock the Container.ContainerStats method
func (mmContainerStats *mContainerMockContainerStats) Set(f func(cid string) (sp1 *entity.Stat, err error)) *ContainerMock {
	if mmContainerStats.defaultExpectation != nil {
		mmContainerStats.mock.t.Fatalf("Default expectation is already set for the Container.ContainerStats method")
	}

	if len(mmContainerStats.expectations) > 0 {
		mmContainerStats.mock.t.Fatalf("Some expectations are already set for the Container.ContainerStats method")
	}

	mmContainerStats.mock.funcContainerStats = f
	return mmContainerStats.mock
}

// When sets expectation for the Container.ContainerStats which will trigger the result defined by the following
// Then helper
func (mmContainerStats *mContainerMockContainerStats) When(cid string) *ContainerMockContainerStatsExpectation {
	if mmContainerStats.mock.funcContainerStats != nil {
		mmContainerStats.mock.t.Fatalf("ContainerMock.ContainerStats mock is already set by Set")
	}

	expectation := &ContainerMockContainerStatsExpectation{
		mock:   mmContainerStats.mock,
		params: &ContainerMockContainerStatsParams{cid},
	}
	mmContainerStats.expectations = append(mmContainerStats.expectations, expectation)
	return expectation
}

// Then sets up Container.ContainerStats return parameters for the expectation previously defined by the When method
func (e *ContainerMockContainerStatsExpectation) Then(sp1 *entity.Stat, err error) *ContainerMock {
	e.results = &ContainerMockContainerStatsResults{sp1, err}
	return e.mock
}

// ContainerStats implements containergateway.Container
func (mmContainerStats *ContainerMock) ContainerStats(cid string) (sp1 *entity.Stat, err error) {
	mm_atomic.AddUint64(&mmContainerStats.beforeContainerStatsCounter, 1)
	defer mm_atomic.AddUint64(&mmContainerStats.afterContainerStatsCounter, 1)

	if mmContainerStats.inspectFuncContainerStats != nil {
		mmContainerStats.inspectFuncContainerStats(cid)
	}

	mm_params := &ContainerMockContainerStatsParams{cid}

	// Record call args
	mmContainerStats.ContainerStatsMock.mutex.Lock()
	mmContainerStats.ContainerStatsMock.callArgs = append(mmContainerStats.ContainerStatsMock.callArgs, mm_params)
	mmContainerStats.ContainerStatsMock.mutex.Unlock()

	for _, e := range mmContainerStats.ContainerStatsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmContainerStats.ContainerStatsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmContainerStats.ContainerStatsMock.defaultExpectation.Counter, 1)
		mm_want := mmContainerStats.ContainerStatsMock.defaultExpectation.params
		mm_got := ContainerMockContainerStatsParams{cid}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmContainerStats.t.Errorf("ContainerMock.ContainerStats got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmContainerStats.ContainerStatsMock.defaultExpectation.results
		if mm_results == nil {
			mmContainerStats.t.Fatal("No results are set for the ContainerMock.ContainerStats")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmContainerStats.funcContainerStats != nil {
		return mmContainerStats.funcContainerStats(cid)
	}
	mmContainerStats.t.Fatalf("Unexpected call to ContainerMock.ContainerStats. %v", cid)
	return
}

// ContainerStatsAfterCounter returns a count of finished ContainerMock.ContainerStats invocations
func (mmContainerStats *ContainerMock) ContainerStatsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainerStats.afterContainerStatsCounter)
}

// ContainerStatsBeforeCounter returns a count of ContainerMock.ContainerStats invocations
func (mmContainerStats *ContainerMock) ContainerStatsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainerStats.beforeContainerStatsCounter)
}

// Calls returns a list of arguments used in each call to ContainerMock.ContainerStats.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmContainerStats *mContainerMockContainerStats) Calls() []*ContainerMockContainerStatsParams {
	mmContainerStats.mutex.RLock()

	argCopy := make([]*ContainerMockContainerStatsParams, len(mmContainerStats.callArgs))
	copy(argCopy, mmContainerStats.callArgs)

	mmContainerStats.mutex.RUnlock()

	return argCopy
}

// MinimockContainerStatsDone returns true if the count of the ContainerStats invocations corresponds
// the number of defined expectations
func (m *ContainerMock) MinimockContainerStatsDone() bool {
	for _, e := range m.ContainerStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainerStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainerStatsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainerStats != nil && mm_atomic.LoadUint64(&m.afterContainerStatsCounter) < 1 {
		return false
	}
	return true
}

// MinimockContainerStatsInspect logs each unmet expectation
func (m *ContainerMock) MinimockContainerStatsInspect() {
	for _, e := range m.ContainerStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContainerMock.ContainerStats with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainerStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainerStatsCounter) < 1 {
		if m.ContainerStatsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContainerMock.ContainerStats")
		} else {
			m.t.Errorf("Expected call to ContainerMock.ContainerStats with params: %#v", *m.ContainerStatsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainerStats != nil && mm_atomic.LoadUint64(&m.afterContainerStatsCounter) < 1 {
		m.t.Error("Expected call to ContainerMock.ContainerStats")
	}
}

type mContainerMockContainerStatsAll struct {
	mock               *ContainerMock
	defaultExpectation *ContainerMockContainerStatsAllExpectation
	expectations       []*ContainerMockContainerStatsAllExpectation
}

// ContainerMockContainerStatsAllExpectation specifies expectation struct of the Container.ContainerStatsAll
type ContainerMockContainerStatsAllExpectation struct {
	mock *ContainerMock

	results *ContainerMockContainerStatsAllResults
	Counter uint64
}

// ContainerMockContainerStatsAllResults contains results of the Container.ContainerStatsAll
type ContainerMockContainerStatsAllResults struct {
	spa1 []*entity.Stat
	err  error
}

// Expect sets up expected params for Container.ContainerStatsAll
func (mmContainerStatsAll *mContainerMockContainerStatsAll) Expect() *mContainerMockContainerStatsAll {
	if mmContainerStatsAll.mock.funcContainerStatsAll != nil {
		mmContainerStatsAll.mock.t.Fatalf("ContainerMock.ContainerStatsAll mock is already set by Set")
	}

	if mmContainerStatsAll.defaultExpectation == nil {
		mmContainerStatsAll.defaultExpectation = &ContainerMockContainerStatsAllExpectation{}
	}

	return mmContainerStatsAll
}

// Inspect accepts an inspector function that has same arguments as the Container.ContainerStatsAll
func (mmContainerStatsAll *mContainerMockContainerStatsAll) Inspect(f func()) *mContainerMockContainerStatsAll {
	if mmContainerStatsAll.mock.inspectFuncContainerStatsAll != nil {
		mmContainerStatsAll.mock.t.Fatalf("Inspect function is already set for ContainerMock.ContainerStatsAll")
	}

	mmContainerStatsAll.mock.inspectFuncContainerStatsAll = f

	return mmContainerStatsAll
}

// Return sets up results that will be returned by Container.ContainerStatsAll
func (mmContainerStatsAll *mContainerMockContainerStatsAll) Return(spa1 []*entity.Stat, err error) *ContainerMock {
	if mmContainerStatsAll.mock.funcContainerStatsAll != nil {
		mmContainerStatsAll.mock.t.Fatalf("ContainerMock.ContainerStatsAll mock is already set by Set")
	}

	if mmContainerStatsAll.defaultExpectation == nil {
		mmContainerStatsAll.defaultExpectation = &ContainerMockContainerStatsAllExpectation{mock: mmContainerStatsAll.mock}
	}
	mmContainerStatsAll.defaultExpectation.results = &ContainerMockContainerStatsAllResults{spa1, err}
	return mmContainerStatsAll.mock
}

//Set uses given function f to mock the Container.ContainerStatsAll method
func (mmContainerStatsAll *mContainerMockContainerStatsAll) Set(f func() (spa1 []*entity.Stat, err error)) *ContainerMock {
	if mmContainerStatsAll.defaultExpectation != nil {
		mmContainerStatsAll.mock.t.Fatalf("Default expectation is already set for the Container.ContainerStatsAll method")
	}

	if len(mmContainerStatsAll.expectations) > 0 {
		mmContainerStatsAll.mock.t.Fatalf("Some expectations are already set for the Container.ContainerStatsAll method")
	}

	mmContainerStatsAll.mock.funcContainerStatsAll = f
	return mmContainerStatsAll.mock
}

// ContainerStatsAll implements containergateway.Container
func (mmContainerStatsAll *ContainerMock) ContainerStatsAll() (spa1 []*entity.Stat, err error) {
	mm_atomic.AddUint64(&mmContainerStatsAll.beforeContainerStatsAllCounter, 1)
	defer mm_atomic.AddUint64(&mmContainerStatsAll.afterContainerStatsAllCounter, 1)

	if mmContainerStatsAll.inspectFuncContainerStatsAll != nil {
		mmContainerStatsAll.inspectFuncContainerStatsAll()
	}

	if mmContainerStatsAll.ContainerStatsAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmContainerStatsAll.ContainerStatsAllMock.defaultExpectation.Counter, 1)

		mm_results := mmContainerStatsAll.ContainerStatsAllMock.defaultExpectation.results
		if mm_results == nil {
			mmContainerStatsAll.t.Fatal("No results are set for the ContainerMock.ContainerStatsAll")
		}
		return (*mm_results).spa1, (*mm_results).err
	}
	if mmContainerStatsAll.funcContainerStatsAll != nil {
		return mmContainerStatsAll.funcContainerStatsAll()
	}
	mmContainerStatsAll.t.Fatalf("Unexpected call to ContainerMock.ContainerStatsAll.")
	return
}

// ContainerStatsAllAfterCounter returns a count of finished ContainerMock.ContainerStatsAll invocations
func (mmContainerStatsAll *ContainerMock) ContainerStatsAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainerStatsAll.afterContainerStatsAllCounter)
}

// ContainerStatsAllBeforeCounter returns a count of ContainerMock.ContainerStatsAll invocations
func (mmContainerStatsAll *ContainerMock) ContainerStatsAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainerStatsAll.beforeContainerStatsAllCounter)
}

// MinimockContainerStatsAllDone returns true if the count of the ContainerStatsAll invocations corresponds
// the number of defined expectations
func (m *ContainerMock) MinimockContainerStatsAllDone() bool {
	for _, e := range m.ContainerStatsAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainerStatsAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainerStatsAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainerStatsAll != nil && mm_atomic.LoadUint64(&m.afterContainerStatsAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockContainerStatsAllInspect logs each unmet expectation
func (m *ContainerMock) MinimockContainerStatsAllInspect() {
	for _, e := range m.ContainerStatsAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ContainerMock.ContainerStatsAll")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainerStatsAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainerStatsAllCounter) < 1 {
		m.t.Error("Expected call to ContainerMock.ContainerStatsAll")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainerStatsAll != nil && mm_atomic.LoadUint64(&m.afterContainerStatsAllCounter) < 1 {
		m.t.Error("Expected call to ContainerMock.ContainerStatsAll")
	}
}

type mContainerMockContainerStop struct {
	mock               *ContainerMock
	defaultExpectation *ContainerMockContainerStopExpectation
	expectations       []*ContainerMockContainerStopExpectation

	callArgs []*ContainerMockContainerStopParams
	mutex    sync.RWMutex
}

// ContainerMockContainerStopExpectation specifies expectation struct of the Container.ContainerStop
type ContainerMockContainerStopExpectation struct {
	mock    *ContainerMock
	params  *ContainerMockContainerStopParams
	results *ContainerMockContainerStopResults
	Counter uint64
}

// ContainerMockContainerStopParams contains parameters of the Container.ContainerStop
type ContainerMockContainerStopParams struct {
	c *entity.Container
}

// ContainerMockContainerStopResults contains results of the Container.ContainerStop
type ContainerMockContainerStopResults struct {
	err error
}

// Expect sets up expected params for Container.ContainerStop
func (mmContainerStop *mContainerMockContainerStop) Expect(c *entity.Container) *mContainerMockContainerStop {
	if mmContainerStop.mock.funcContainerStop != nil {
		mmContainerStop.mock.t.Fatalf("ContainerMock.ContainerStop mock is already set by Set")
	}

	if mmContainerStop.defaultExpectation == nil {
		mmContainerStop.defaultExpectation = &ContainerMockContainerStopExpectation{}
	}

	mmContainerStop.defaultExpectation.params = &ContainerMockContainerStopParams{c}
	for _, e := range mmContainerStop.expectations {
		if minimock.Equal(e.params, mmContainerStop.defaultExpectation.params) {
			mmContainerStop.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmContainerStop.defaultExpectation.params)
		}
	}

	return mmContainerStop
}

// Inspect accepts an inspector function that has same arguments as the Container.ContainerStop
func (mmContainerStop *mContainerMockContainerStop) Inspect(f func(c *entity.Container)) *mContainerMockContainerStop {
	if mmContainerStop.mock.inspectFuncContainerStop != nil {
		mmContainerStop.mock.t.Fatalf("Inspect function is already set for ContainerMock.ContainerStop")
	}

	mmContainerStop.mock.inspectFuncContainerStop = f

	return mmContainerStop
}

// Return sets up results that will be returned by Container.ContainerStop
func (mmContainerStop *mContainerMockContainerStop) Return(err error) *ContainerMock {
	if mmContainerStop.mock.funcContainerStop != nil {
		mmContainerStop.mock.t.Fatalf("ContainerMock.ContainerStop mock is already set by Set")
	}

	if mmContainerStop.defaultExpectation == nil {
		mmContainerStop.defaultExpectation = &ContainerMockContainerStopExpectation{mock: mmContainerStop.mock}
	}
	mmContainerStop.defaultExpectation.results = &ContainerMockContainerStopResults{err}
	return mmContainerStop.mock
}

//Set uses given function f to mock the Container.ContainerStop method
func (mmContainerStop *mContainerMockContainerStop) Set(f func(c *entity.Container) (err error)) *ContainerMock {
	if mmContainerStop.defaultExpectation != nil {
		mmContainerStop.mock.t.Fatalf("Default expectation is already set for the Container.ContainerStop method")
	}

	if len(mmContainerStop.expectations) > 0 {
		mmContainerStop.mock.t.Fatalf("Some expectations are already set for the Container.ContainerStop method")
	}

	mmContainerStop.mock.funcContainerStop = f
	return mmContainerStop.mock
}

// When sets expectation for the Container.ContainerStop which will trigger the result defined by the following
// Then helper
func (mmContainerStop *mContainerMockContainerStop) When(c *entity.Container) *ContainerMockContainerStopExpectation {
	if mmContainerStop.mock.funcContainerStop != nil {
		mmContainerStop.mock.t.Fatalf("ContainerMock.ContainerStop mock is already set by Set")
	}

	expectation := &ContainerMockContainerStopExpectation{
		mock:   mmContainerStop.mock,
		params: &ContainerMockContainerStopParams{c},
	}
	mmContainerStop.expectations = append(mmContainerStop.expectations, expectation)
	return expectation
}

// Then sets up Container.ContainerStop return parameters for the expectation previously defined by the When method
func (e *ContainerMockContainerStopExpectation) Then(err error) *ContainerMock {
	e.results = &ContainerMockContainerStopResults{err}
	return e.mock
}

// ContainerStop implements containergateway.Container
func (mmContainerStop *ContainerMock) ContainerStop(c *entity.Container) (err error) {
	mm_atomic.AddUint64(&mmContainerStop.beforeContainerStopCounter, 1)
	defer mm_atomic.AddUint64(&mmContainerStop.afterContainerStopCounter, 1)

	if mmContainerStop.inspectFuncContainerStop != nil {
		mmContainerStop.inspectFuncContainerStop(c)
	}

	mm_params := &ContainerMockContainerStopParams{c}

	// Record call args
	mmContainerStop.ContainerStopMock.mutex.Lock()
	mmContainerStop.ContainerStopMock.callArgs = append(mmContainerStop.ContainerStopMock.callArgs, mm_params)
	mmContainerStop.ContainerStopMock.mutex.Unlock()

	for _, e := range mmContainerStop.ContainerStopMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmContainerStop.ContainerStopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmContainerStop.ContainerStopMock.defaultExpectation.Counter, 1)
		mm_want := mmContainerStop.ContainerStopMock.defaultExpectation.params
		mm_got := ContainerMockContainerStopParams{c}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmContainerStop.t.Errorf("ContainerMock.ContainerStop got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmContainerStop.ContainerStopMock.defaultExpectation.results
		if mm_results == nil {
			mmContainerStop.t.Fatal("No results are set for the ContainerMock.ContainerStop")
		}
		return (*mm_results).err
	}
	if mmContainerStop.funcContainerStop != nil {
		return mmContainerStop.funcContainerStop(c)
	}
	mmContainerStop.t.Fatalf("Unexpected call to ContainerMock.ContainerStop. %v", c)
	return
}

// ContainerStopAfterCounter returns a count of finished ContainerMock.ContainerStop invocations
func (mmContainerStop *ContainerMock) ContainerStopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainerStop.afterContainerStopCounter)
}

// ContainerStopBeforeCounter returns a count of ContainerMock.ContainerStop invocations
func (mmContainerStop *ContainerMock) ContainerStopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainerStop.beforeContainerStopCounter)
}

// Calls returns a list of arguments used in each call to ContainerMock.ContainerStop.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmContainerStop *mContainerMockContainerStop) Calls() []*ContainerMockContainerStopParams {
	mmContainerStop.mutex.RLock()

	argCopy := make([]*ContainerMockContainerStopParams, len(mmContainerStop.callArgs))
	copy(argCopy, mmContainerStop.callArgs)

	mmContainerStop.mutex.RUnlock()

	return argCopy
}

// MinimockContainerStopDone returns true if the count of the ContainerStop invocations corresponds
// the number of defined expectations
func (m *ContainerMock) MinimockContainerStopDone() bool {
	for _, e := range m.ContainerStopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainerStopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainerStopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainerStop != nil && mm_atomic.LoadUint64(&m.afterContainerStopCounter) < 1 {
		return false
	}
	return true
}

// MinimockContainerStopInspect logs each unmet expectation
func (m *ContainerMock) MinimockContainerStopInspect() {
	for _, e := range m.ContainerStopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContainerMock.ContainerStop with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainerStopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainerStopCounter) < 1 {
		if m.ContainerStopMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContainerMock.ContainerStop")
		} else {
			m.t.Errorf("Expected call to ContainerMock.ContainerStop with params: %#v", *m.ContainerStopMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainerStop != nil && mm_atomic.LoadUint64(&m.afterContainerStopCounter) < 1 {
		m.t.Error("Expected call to ContainerMock.ContainerStop")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ContainerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockContainerGetInspect()

		m.MinimockContainerGetAllInspect()

		m.MinimockContainerKillInspect()

		m.MinimockContainerRefreshInspect()

		m.MinimockContainerRemoveInspect()

		m.MinimockContainerRestartInspect()

		m.MinimockContainerRunInspect()

		m.MinimockContainerStatsInspect()

		m.MinimockContainerStatsAllInspect()

		m.MinimockContainerStopInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ContainerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ContainerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockContainerGetDone() &&
		m.MinimockContainerGetAllDone() &&
		m.MinimockContainerKillDone() &&
		m.MinimockContainerRefreshDone() &&
		m.MinimockContainerRemoveDone() &&
		m.MinimockContainerRestartDone() &&
		m.MinimockContainerRunDone() &&
		m.MinimockContainerStatsDone() &&
		m.MinimockContainerStatsAllDone() &&
		m.MinimockContainerStopDone()
}
